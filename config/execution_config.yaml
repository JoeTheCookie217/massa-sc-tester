# this is an example & functional config containing various steps for 2 slots

# slot (0, 0)
- slot:
    period: 0
    thread: 0
  execution_steps:
    # execute the given smart contract main function
    - name: execute_main_function
      config:
        type: execute_sc
        path: ./config/basic_sc.wasm
        function: main
        parameter: []
        gas: 100000
        call_stack:
          # call stack and sender addresses do not need to exist in the ledger
          # no check is performed for the emitted coins
          - address: user_address
            coins: 8
    # save the given smart contract on the ledger
    # setup its balance and datastore as well
    - name: save_sc_on_ledger
      config:
        type: write_ledger_entry
        address: smart_contract_address
        bytecode: ./config/basic_sc.wasm
        balance: 16
        datastore:
          key1: [1, 2, 3]
          key2: [4, 5, 6]
    # call the recive function of the previously saved smart contract
    - name: call_receive_function
      config:
        type: call_sc
        address: smart_contract_address
        function: receive
        parameter: [7, 8, 9]
        gas: 100000
        call_stack:
          - address: user_address
            coins: 32
    # read the events generated by smart contracts between (0, 0) and (0, 1)
    # we expect one from execute_main_function and call_receive_function
    - name: read_emitted_events
      config:
        type: read_events
        start:
          period: 0
          thread: 0
        end:
          period: 0
          thread: 1
    # read smart contract address ledger entry
    # doing this allows to see any potential changes after calling one of the sc functions
    - name: read_sc_address
      config:
        type: read_ledger_entry
        address: smart_contract_address
    # emit an asynchronous message towards smart_contract_address receive function
    # this message is to be executed at (2, 0)
    - name: emit_new_async_message
      config:
        type: write_async_message
        sender_address: user_address
        target_address: smart_contract_address
        target_handler: receive
        execution_slot:
          period: 2
          thread: 0
        gas: 200000
        coins: 64
        data: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    # read the async messages to be executed between (0, 0) and (4, 0)
    # we expect to see the one we created above
    - name: read_async_message_pool_before_execution
      config:
        type: read_async_messages
        start:
          period: 0
          thread: 0
        end:
          period: 4
          thread: 0

# slot (2, 0)
# here the first step in the trace is the asynchronous message execution
# these can not be specified and are performed automatically
- slot:
    period: 2
    thread: 0
  execution_steps:
    # read the events generated by smart contracts between (2, 0) and (2, 1)
    # we expect one from the asynchronous message execution
    - name: read_events_after_execution
      config:
        type: read_events
        start:
          period: 2
          thread: 0
        end:
          period: 2
          thread: 1
    # read the async messages to be executed between (0, 0) and (4, 0) again
    # we expect to see an empty list as the message has been executed
    - name: read_async_message_pool_after_execution
      config:
        type: read_async_messages
        start:
          period: 0
          thread: 0
        end:
          period: 4
          thread: 0
